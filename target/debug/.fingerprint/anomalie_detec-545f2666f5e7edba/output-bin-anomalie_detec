{"$message_type":"diagnostic","message":"the trait bound `ArrayBase<OwnedRepr<_>, Dim<[usize; 2]>>: From<Vec<Vec<f64>>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":1803,"byte_end":1809,"line_start":88,"line_end":88,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"    let features = Array2::from(data);","highlight_start":20,"highlight_end":26}],"label":"the trait `From<Vec<Vec<f64>>>` is not implemented for `ArrayBase<OwnedRepr<_>, Dim<[usize; 2]>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `ArrayBase<CowRepr<'_, A>, D>` implements `From<&ArrayBase<S, D>>`\n  `ArrayBase<CowRepr<'_, A>, D>` implements `From<ArrayBase<OwnedRepr<A>, D>>`\n  `ArrayBase<CowRepr<'_, A>, D>` implements `From<ArrayBase<ViewRepr<&A>, D>>`\n  `ArrayBase<CowRepr<'_, A>, Dim<[usize; 1]>>` implements `From<&Slice>`\n  `ArrayBase<OwnedArcRepr<A>, D>` implements `From<ArrayBase<OwnedRepr<A>, D>>`\n  `ArrayBase<OwnedRepr<A>, Dim<[usize; 2]>>` implements `From<Vec<[A; N]>>`\n  `ArrayBase<OwnedRepr<A>, Dim<[usize; 3]>>` implements `From<Vec<[[A; M]; N]>>`\n  `ArrayBase<OwnedRepr<A>, Dim<[usize; 4]>>` implements `From<Vec<[[[A; L]; M]; N]>>`\nand 12 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `ArrayBase<OwnedRepr<_>, Dim<[usize; 2]>>: From<Vec<Vec<f64>>>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:88:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let features = Array2::from(data);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<Vec<Vec<f64>>>` is not implemented for `ArrayBase<OwnedRepr<_>, Dim<[usize; 2]>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m             `ArrayBase<CowRepr<'_, A>, D>` implements `From<&ArrayBase<S, D>>`\u001b[0m\n\u001b[0m             `ArrayBase<CowRepr<'_, A>, D>` implements `From<ArrayBase<OwnedRepr<A>, D>>`\u001b[0m\n\u001b[0m             `ArrayBase<CowRepr<'_, A>, D>` implements `From<ArrayBase<ViewRepr<&A>, D>>`\u001b[0m\n\u001b[0m             `ArrayBase<CowRepr<'_, A>, Dim<[usize; 1]>>` implements `From<&Slice>`\u001b[0m\n\u001b[0m             `ArrayBase<OwnedArcRepr<A>, D>` implements `From<ArrayBase<OwnedRepr<A>, D>>`\u001b[0m\n\u001b[0m             `ArrayBase<OwnedRepr<A>, Dim<[usize; 2]>>` implements `From<Vec<[A; N]>>`\u001b[0m\n\u001b[0m             `ArrayBase<OwnedRepr<A>, Dim<[usize; 3]>>` implements `From<Vec<[[A; M]; N]>>`\u001b[0m\n\u001b[0m             `ArrayBase<OwnedRepr<A>, Dim<[usize; 4]>>` implements `From<Vec<[[[A; L]; M]; N]>>`\u001b[0m\n\u001b[0m           and 12 others\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: Records` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":2327,"byte_end":2339,"line_start":105,"line_end":105,"column_start":36,"column_end":48,"is_primary":true,"text":[{"text":"    let dataset = DatasetBase::new(data.clone(), ());","highlight_start":36,"highlight_end":48}],"label":"the trait `Records` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/data.rs","byte_start":2310,"byte_end":2326,"line_start":105,"line_end":105,"column_start":19,"column_end":35,"is_primary":false,"text":[{"text":"    let dataset = DatasetBase::new(data.clone(), ());","highlight_start":19,"highlight_end":35}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Records`:\n  &R\n  ()\n  linfa::DatasetBase<D, T>\n  ndarray::ArrayBase<S, I>","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `dataset::impl_dataset::<impl linfa::DatasetBase<R, S>>::new`","code":null,"level":"note","spans":[{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/impl_dataset.rs","byte_start":922,"byte_end":925,"line_start":25,"line_end":25,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new(records: R, targets: S) -> DatasetBase<R, S> {","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/impl_dataset.rs","byte_start":699,"byte_end":706,"line_start":17,"line_end":17,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"impl<R: Records, S> DatasetBase<R, S> {","highlight_start":9,"highlight_end":16}],"label":"required by this bound in `dataset::impl_dataset::<impl DatasetBase<R, S>>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: Records` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:105:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let dataset = DatasetBase::new(data.clone(), ());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Records` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Records`:\u001b[0m\n\u001b[0m              &R\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              linfa::DatasetBase<D, T>\u001b[0m\n\u001b[0m              ndarray::ArrayBase<S, I>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `dataset::impl_dataset::<impl linfa::DatasetBase<R, S>>::new`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/impl_dataset.rs:17:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<R: Records, S> DatasetBase<R, S> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `dataset::impl_dataset::<impl DatasetBase<R, S>>::new`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(records: R, targets: S) -> DatasetBase<R, S> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: Records` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":2310,"byte_end":2344,"line_start":105,"line_end":105,"column_start":19,"column_end":53,"is_primary":true,"text":[{"text":"    let dataset = DatasetBase::new(data.clone(), ());","highlight_start":19,"highlight_end":53}],"label":"the trait `Records` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Records`:\n  &R\n  ()\n  linfa::DatasetBase<D, T>\n  ndarray::ArrayBase<S, I>","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `linfa::DatasetBase`","code":null,"level":"note","spans":[{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/mod.rs","byte_start":5259,"byte_end":5270,"line_start":175,"line_end":175,"column_start":12,"column_end":23,"is_primary":false,"text":[{"text":"pub struct DatasetBase<R, T>","highlight_start":12,"highlight_end":23}],"label":"required by a bound in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/mod.rs","byte_start":5292,"byte_end":5299,"line_start":177,"line_end":177,"column_start":8,"column_end":15,"is_primary":true,"text":[{"text":"    R: Records,","highlight_start":8,"highlight_end":15}],"label":"required by this bound in `DatasetBase`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: Records` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:105:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let dataset = DatasetBase::new(data.clone(), ());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Records` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Records`:\u001b[0m\n\u001b[0m              &R\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              linfa::DatasetBase<D, T>\u001b[0m\n\u001b[0m              ndarray::ArrayBase<S, I>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `linfa::DatasetBase`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-0.7.1/src/dataset/mod.rs:177:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct DatasetBase<R, T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    R: Records,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `DatasetBase`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fit` exists for struct `DbscanParams<{float}, L2Dist, CommonNearestNeighbour>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":2365,"byte_end":2416,"line_start":106,"line_end":108,"column_start":20,"column_end":10,"is_primary":false,"text":[{"text":"    let clusters = Dbscan::params(5)","highlight_start":20,"highlight_end":37},{"text":"        .tolerance(0.5)","highlight_start":1,"highlight_end":24},{"text":"        .fit(&dataset)?;","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-clustering-0.7.1/src/dbscan/hyperparams.rs","byte_start":480,"byte_end":555,"line_start":15,"line_end":15,"column_start":1,"column_end":76,"is_primary":false,"text":[{"text":"pub struct DbscanValidParams<F: Float, D: Distance<F>, N: NearestNeighbour> {","highlight_start":1,"highlight_end":76}],"label":"doesn't satisfy `_: Fit<_, _, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-clustering-0.7.1/src/dbscan/hyperparams.rs","byte_start":801,"byte_end":871,"line_start":24,"line_end":24,"column_start":1,"column_end":71,"is_primary":false,"text":[{"text":"pub struct DbscanParams<F: Float, D: Distance<F>, N: NearestNeighbour>(DbscanValidParams<F, D, N>);","highlight_start":1,"highlight_end":71}],"label":"doesn't satisfy `_: Fit<_, _, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/data.rs","byte_start":2416,"byte_end":2419,"line_start":108,"line_end":108,"column_start":10,"column_end":13,"is_primary":true,"text":[{"text":"        .fit(&dataset)?;","highlight_start":10,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`DbscanValidParams<{float}, linfa_nn::distance::L2Dist, linfa_nn::CommonNearestNeighbour>: linfa::prelude::Fit<_, _, _>`\nwhich is required by `DbscanParams<{float}, linfa_nn::distance::L2Dist, linfa_nn::CommonNearestNeighbour>: linfa::prelude::Fit<_, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `fit` exists for struct `DbscanParams<{float}, L2Dist, CommonNearestNeighbour>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:108:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let clusters = Dbscan::params(5)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ____________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .tolerance(0.5)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .fit(&dataset)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/wato/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linfa-clustering-0.7.1/src/dbscan/hyperparams.rs:15:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct DbscanValidParams<F: Float, D: Distance<F>, N: NearestNeighbour> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: Fit<_, _, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct DbscanParams<F: Float, D: Distance<F>, N: NearestNeighbour>(DbscanValidParams<F, D, N>);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: Fit<_, _, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `DbscanValidParams<{float}, linfa_nn::distance::L2Dist, linfa_nn::CommonNearestNeighbour>: linfa::prelude::Fit<_, _, _>`\u001b[0m\n\u001b[0m            which is required by `DbscanParams<{float}, linfa_nn::distance::L2Dist, linfa_nn::CommonNearestNeighbour>: linfa::prelude::Fit<_, _, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `max` found for struct `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":3318,"byte_end":3321,"line_start":134,"line_end":134,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let max_time = data.column(0).max().unwrap_or(1.0);","highlight_start":35,"highlight_end":38}],"label":"`ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"call `.into_iter()` first","code":null,"level":"help","spans":[{"file_name":"src/data.rs","byte_start":3318,"byte_end":3318,"line_start":134,"line_end":134,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"    let max_time = data.column(0).max().unwrap_or(1.0);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":"into_iter().","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `max` found for struct `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:134:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let max_time = data.column(0).max().unwrap_or(1.0);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: call `.into_iter()` first\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let max_time = data.column(0).\u001b[0m\u001b[0m\u001b[38;5;10minto_iter().\u001b[0m\u001b[0mmax().unwrap_or(1.0);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `max` found for struct `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/data.rs","byte_start":3391,"byte_end":3394,"line_start":135,"line_end":135,"column_start":52,"column_end":55,"is_primary":true,"text":[{"text":"    let max_amount = data.column(data.ncols() - 1).max().unwrap_or(1.0);","highlight_start":52,"highlight_end":55}],"label":"`ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"call `.into_iter()` first","code":null,"level":"help","spans":[{"file_name":"src/data.rs","byte_start":3391,"byte_end":3391,"line_start":135,"line_end":135,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"    let max_amount = data.column(data.ncols() - 1).max().unwrap_or(1.0);","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":"into_iter().","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `max` found for struct `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/data.rs:135:52\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let max_amount = data.column(data.ncols() - 1).max().unwrap_or(1.0);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: call `.into_iter()` first\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let max_amount = data.column(data.ncols() - 1).\u001b[0m\u001b[0m\u001b[38;5;10minto_iter().\u001b[0m\u001b[0mmax().unwrap_or(1.0);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 6 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 6 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
